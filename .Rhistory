colnames(DF_answer)[1] <- "Answer_Key" #Remove weird characters
source("R/prop_correct_free.R")
source("R/arrange_data.R")
DF_test <- subset(DF_test,
List_Type == "Cat_Recall_L1")
DF_long <- arrange_data(responses = DF_test$Response,
sep = " ",
id = DF_test$Username,
other = DF_test$Version,
other.names = "Version")
scored_output <- prop_correct_free( data = DF_long,
responses = "response",
key = DF_answer$Answer_Key,
id = "Sub.ID",
cutoff = 1,
flag = TRUE,
group.by = "Version")
source("R/crp.R")
names(scored_output$DF_Scored)
source('~/GitHub/2.5 packages/lrd/tests/test crp.R', echo=TRUE)
crp_output <- crp(data = scored_output$DF_Scored,
position = "position",
answer = "Answer",
id = "Sub.ID",
key = DF_answer$Answer_Key,
scored = "Scored")
head(crp_output)
View(serial_output)
#create answer key with order
if (sum(duplicated(key)) > 0){
stop("Your answer key contains duplicates. Please check your data.")
}
key <- data.frame("Answer" = key, "Tested.Position" = 1:length(key))
#merge that with the data
DF <- as.data.frame(data)
colnames(DF)[grepl(answer, colnames(DF))] <- "Answer"
colnames(DF)[grepl(position, colnames(DF))] <- "Answered.Position"
colnames(DF)[grepl(scored, colnames(DF))] <- "Scored"
colnames(DF)[grepl(id, colnames(DF))] <- "Sub.ID"
DF <- merge(DF, key, by = "Answer")
#calculate the number of times within window
DF$Answered.Position <- as.numeric(DF$Answered.Position)
DF$Tested.Position <- as.numeric(DF$Tested.Position)
View(DF)
DF_first <- subset(DF, Answered.Position == 1)
View(DF_first)
pfr_table <- table(DF_first$Test)
pfr_table <- table(DF_first$Tested.Position)
pfr_table
group.by
if(!is.null(group.by)){
pfr_table <- table(DF_first[ , c("Tested.Position", group.by)])
}
pfr_table
pfr_table <- as.data.frame(table(DF_first[ , c("Tested.Position", group.by)]))
pfr_table
DF_unique <- unique(DF[ , c("Sub.ID", group.by)])
group_sizes <- as.data.frame(table(DF_unique[ , group.by]))
group_sizes$group_code <- paste(group_sizes[ , -ncol(group_sizes)])
group_code <- paste(pfr_table[ , group.by])
pfr_table$pfr <- NA
for (group in group_code){
pfr_table$pfr[group_code == group] <- pfr_table$Freq[group_code == group] / group_sizes$Freq[group_sizes$group_code == group]
}
View(pfr_table)
names(pfr_table)
DF_test <- read.csv("data/free_data.csv")
DF_answer <- read.csv("data/answer_key_free2.csv")
colnames(DF_answer)[1] <- "Answer_Key" #Remove weird characters
source("R/prop_correct_free.R")
source("R/arrange_data.R")
DF_test <- subset(DF_test,
List_Type == "Cat_Recall_L1")
DF_long <- arrange_data(responses = DF_test$Response,
sep = " ",
id = DF_test$Username,
other = DF_test$Version,
other.names = "Version")
scored_output <- prop_correct_free( data = DF_long,
responses = "response",
key = DF_answer$Answer_Key,
id = "Sub.ID",
cutoff = 1,
flag = TRUE,
group.by = "Version")
source("R/pfr.R")
pfr_output <- pfr(data = scored_output$DF_Scored,
position = "position",
answer = "Answer",
id = "Sub.ID",
key = DF_answer$Answer_Key,
scored = "Scored",
group.by = "Version")
head(pfr_output)
colnames(DF
)
c("Responses", "Sub.ID", "Answer",
"Scored", "Answered.Position",
"Tested.Position",
colnames(pfr_table))
#add back in other columns that are one to one
other.columns <- setdiff(colnames(DF),
c("Responses", "Sub.ID", "Answer",
"Scored", "Answered.Position",
"Tested.Position",
colnames(pfr_table)))
other.columns
crp_output
View(crp_output)
check()
library(devtools)
check()
roxygen2::roxygenise()
check()
check()
check()
roxygen2::roxygenise()
check()
roxygen2::roxygenise()
check()
check()
corpus = "en"
gzcon(url(paste("https://rb.gy/eabzqf.", corpus, ".gz", sep="")))
check()
roxygen2::roxygenise()
check()
roxygen2::roxygenise()
check()
load("~/GitHub/2.5 packages/lrd/data/wide_data.RData")
View(wide_data)
data(mtcars)
View(mtcars)
library(devtools)
check()
data(mtcars)
View(mtcars)
load("data/wide_data.RData")
save(wide_data, "data/wide_data.RData")
?save
save(wide_data, file =  "data/wide_data.RData")
getwd()
check()
load("data/wide_data.RData")
ls
ls()
load("data/wide_data.RData")
str(wide_data)
wide_data <- read.csc("data/wide_data.csv")
wide_data <- read.csv("data/wide_data.csv")
wide_data <- read.csv("data/wide_data.csv")
save(wide_data, file = "wide_data.RData")
roxygen2::roxygenise()
check()
wide_data <- rio::import("wide_data.xlsx")
save(wide_data, file = "wide_data.RData")
roxygen2::roxygenise()
check()
check()
roxygen2::roxygenise()
check()
data("data/free_data.RData")
load("/Users/buchanan/GitHub/2.5 packages/lrd/data/free_data.RData")
data("wide_data.RData")
data(wide_data)
roxygen2::roxygenise()
check()
data(wide_data)
DF_long <- arrange_data(
data = wide_data,
responses = "Response",
sep = ",",
id = "Sub.ID")
head(DF_long)
data(free_data)
names(free_data)
free_data <- subset(free_data,
List_Type == "Cat_Recall_L1")
DF_long <- arrange_data(data = free_data,
responses = "Response",
sep = " ",
id = "Username")
data = free_data
responses = "Response"
sep = " "
id = "Username"
#get the data
data <- as.data.frame(data)
#split the strings, returns a list
answers <- strsplit(data[ , responses], split = sep)
#list to long
df <- data.frame(response = unlist(answers))
#take out any extra spaces
df$response <- gsub("\\s+", " ", df$response)
df$response <- trimws(df$response, "both")
#add participant id
df$Sub.ID <- rep(data[ , id], unlist(lapply(answers, length)))
#add position tag
df$position <- ave(df$Sub.ID, df$Sub.ID, FUN = seq_along)
#add back in other columns that are one to one
other.columns <- setdiff(colnames(data),
c("response", "Sub.ID", "position", responses))
for (col in other.columns){
data_temp <- unique(data[ , c("Sub.ID", col)])
if (sum(duplicated(data$Sub.ID)) == 0){
df <- merge(df, data_temp, by = "Sub.ID")
}
}
names(data)
other.columns
names(DF)
names(DF)
names(df)
#add back in other columns that are one to one
other.columns <- setdiff(colnames(data),
c("response", "Sub.ID", "position", responses))
other.columns
roxygen2::roxygenise()
roxygen2::roxygenise()
check()
data(free_data)
free_data <- subset(free_data,
List_Type == "Cat_Recall_L1")
data = free_data
responses = "Response"
sep = " "
id = "Username"
#get the data
data <- as.data.frame(data)
colnames(data)[grepl(id, colnames(data))] <- "Sub.ID"
names(data)
#split the strings, returns a list
answers <- strsplit(data[ , responses], split = sep)
#list to long
df <- data.frame(response = unlist(answers))
#take out any extra spaces
df$response <- gsub("\\s+", " ", df$response)
df$response <- trimws(df$response, "both")
#add participant id
df$Sub.ID <- rep(data[ , id], unlist(lapply(answers, length)))
#add participant id
df$Sub.ID <- rep(data$Sub.ID, unlist(lapply(answers, length)))
#add position tag
df$position <- ave(df$Sub.ID, df$Sub.ID, FUN = seq_along)
#add back in other columns that are one to one
other.columns <- setdiff(colnames(data),
c("response", "Sub.ID", "position", responses))
for (col in other.columns){
data_temp <- unique(data[ , c("Sub.ID", col)])
if (sum(duplicated(data$Sub.ID)) == 0){
df <- merge(df, data_temp, by = "Sub.ID")
}
}
library(roxygen2)
roxygenise()
roxygenise()
check()
roxygenise()
check()
install_github("npm27/lrd")
data(wide_data)
roxygenize()
check()
install_github("npm27/lrd")
DF_test <- read.csv("data/free_data.csv")
DF_answer <- read.csv("data/answer_key_free2.csv")
colnames(DF_answer)[1] <- "Answer_Key" #Remove weird characters
source("R/prop_correct_free.R")
source("R/arrange_data.R")
DF_test <- subset(DF_test,
List_Type == "Cat_Recall_L1")
DF_long <- arrange_data(responses = DF_test$Response,
sep = " ",
id = DF_test$Username,
other = DF_test$Version,
other.names = "Version")
scored_output <- prop_correct_free( data = DF_long,
responses = "response",
key = DF_answer$Answer_Key,
id = "Sub.ID",
cutoff = 1,
flag = TRUE,
group.by = "Version")
#key = DF_answer$Answer_Key
#data = scored_output$DF_Scored
#position = "position"
#scored = "Scored"
#answer = "Answer"
#group.by = "Version"
source("R/serial_position.R")
serial_output <- serial_position(data = scored_output$DF_Scored,
key = DF_answer$Answer_Key,
position = "position",
scored = "Scored",
answer = "Answer",
group.by = "Version")
head(serial_output)
tapply(serial_output$Proportion.Correct, serial_output$Tested.Position, mean)
DF_test <- read.csv("data/free_data.csv")
DF_answer <- read.csv("data/answer_key_free2.csv")
colnames(DF_answer)[1] <- "Answer_Key" #Remove weird characters
source("R/prop_correct_free.R")
source("R/arrange_data.R")
DF_test <- subset(DF_test,
List_Type == "Cat_Recall_L1")
DF_long <- arrange_data(data = DF_test,
responses = "Response",
sep = " ",
id = "Username")
scored_output <- prop_correct_free( data = DF_long,
responses = "response",
key = DF_answer$Answer_Key,
id = "Sub.ID",
cutoff = 1,
flag = TRUE,
group.by = "Version")
library(lrd)
DF_test <- read.csv("data/free_data.csv")
DF_answer <- read.csv("data/answer_key_free2.csv")
colnames(DF_answer)[1] <- "Answer_Key" #Remove weird characters
source("R/prop_correct_free.R")
library(lrd)
load(free_data)
data(free_data)
data("answer_key_free2")
DF_test <- free_data
DF_answer <- answer_key_free2
colnames(DF_answer)[1] <- "Answer_Key" #Remove weird characters
DF_test <- subset(DF_test,
List_Type == "Cat_Recall_L1")
DF_long <- arrange_data(data = DF_test,
responses = "Response",
sep = " ",
id = "Username")
scored_output <- prop_correct_free( data = DF_long,
responses = "response",
key = DF_answer$Answer_Key,
id = "Sub.ID",
cutoff = 1,
flag = TRUE,
group.by = "Version")
serial_output <- serial_position(data = scored_output$DF_Scored,
key = DF_answer$Answer_Key,
position = "position",
scored = "Scored",
answer = "Answer",
group.by = "Version")
head(serial_output)
tapply(serial_output$Proportion.Correct, serial_output$Tested.Position, mean)
ggplot(data = serial_output,
aes(x = Tested.Position, y = serial_output$Proportion.Correct)) +
geom_line() +
geom_point()
##Quick plot
library(ggplot2)
ggplot(data = serial_output,
aes(x = Tested.Position, y = serial_output$Proportion.Correct)) +
geom_line() +
geom_point()
ggplot(data = serial_output,
aes(x = Tested.Position, y = Proportion.Correct)) +
geom_line() +
geom_point()
View(serial_position())
View(serial_output)
ggplot(data = serial_output,
aes(x = Tested.Position, y = Proportion.Correct, color = Version)) +
geom_line() +
geom_point()
ggplot(data = serial_output,
aes(x = Tested.Position, y = Proportion.Correct, color = Version)) +
geom_line() +
geom_point() +
theme_bw()
ggplot(data = serial_output,
aes(x = Tested.Position, y = Proportion.Correct, color = Version)) +
geom_line() +
geom_point() +
xlab("Tested Position") +
ylab("Proportion Correct") +
theme_bw()
ggplot(data = serial_output,
aes(x = Tested.Position, y = Proportion.Correct, color = Version)) +
geom_line() +
geom_point() +
geom_errorbar(aes(ymin = Proportion.Correct - SE, ymax = Proportion.Correct + SE),
width = .2, position = position_dodge()) +
xlab("Tested Position") +
ylab("Proportion Correct") +
theme_bw()
DF_test <- read.csv("data/free_data.csv")
DF_answer <- read.csv("data/answer_key_free2.csv")
colnames(DF_answer)[1] <- "Answer_Key" #Remove weird characters
source("R/prop_correct_free.R")
source("R/arrange_data.R")
DF_test <- subset(DF_test,
List_Type == "Cat_Recall_L1")
DF_long <- arrange_data(responses = DF_test$Response,
sep = " ",
id = DF_test$Username,
other = DF_test$Version,
other.names = "Version")
scored_output <- prop_correct_free( data = DF_long,
responses = "response",
key = DF_answer$Answer_Key,
id = "Sub.ID",
cutoff = 1,
flag = TRUE,
group.by = "Version")
View(scored_output$DF_Participant)
View(scored_output$DF_Scored)
names(scored_output$DF_Scored)
source("R/pfr.R")
pfr_output <- pfr(data = scored_output$DF_Scored,
position = "position",
answer = "Answer",
id = "Sub.ID",
key = DF_answer$Answer_Key,
scored = "Scored",
group.by = "Version")
head(pfr_output)
crp_output <- crp(data = scored_output$DF_Scored,
position = "position",
answer = "Answer",
id = "Sub.ID",
key = DF_answer$Answer_Key,
scored = "Scored")
head(crp_output)
shiny::runApp('shiny')
runApp('shiny')
runApp('shiny')
DF_test <- read.csv("data/cued_data.csv")
source("R/prop_correct_cued.R")
#data = DF_test
#responses = "response"
#key = "key"
#key.trial = "trial"
#id = "id"
#id.trial = "trial"
#cutoff = 1
#flag = TRUE
#group.by = "condition"
#group.by and "" key answers
scored_output <- prop_correct_free(data = DF_test,
responses = "response",
key = "key",
key.trial = "trial",
id = "id",
id.trial = "trial",
cutoff = 1,
flag = TRUE,
group.by = "condition")
head(scored_output$DF_Scored)
head(scored_output$DF_Participant)
head(scored_output$DF_Group)
#group.by and $ key answers
scored_output <- prop_correct_free(data = DF_test,
responses = "response",
key = DF_test$key,
key.trial = DF_test$trial,
id = "id",
id.trial = "trial",
cutoff = 1,
flag = TRUE,
group.by = "condition")
head(scored_output$DF_Scored)
head(scored_output$DF_Participant)
head(scored_output$DF_Group)
#Test multiple group.by
#Make condition2 column
DF_test$condition2 = c(rep("c", times = 8631), rep("d", times = 8632))
scored_output <- prop_correct_free(data = DF_test,
responses = "response",
key = DF_test$key,
key.trial = DF_test$trial,
id = "id",
id.trial = "trial",
cutoff = 1,
flag = TRUE,
group.by = c("condition", "condition2"))
head(scored_output$DF_Scored)
head(scored_output$DF_Participant)
head(scored_output$DF_Group)
DF_test <- read.csv("data/cued_data.csv")
library(lrd)
data(cued_data)
DF_test <- cued_data
source("R/prop_correct_cued.R")
#group.by and "" key answers
scored_output <- prop_correct_free(data = DF_test,
responses = "response",
key = "key",
key.trial = "trial",
id = "id",
id.trial = "trial",
cutoff = 1,
flag = TRUE,
group.by = "condition")
#group.by and "" key answers
scored_output <- prop_correct_cued(data = DF_test,
responses = "response",
key = "key",
key.trial = "trial",
id = "id",
id.trial = "trial",
cutoff = 1,
flag = TRUE,
group.by = "condition")
head(scored_output$DF_Participant)
?textInput
runApp('shiny')
runApp('shiny')
devtools::check()
