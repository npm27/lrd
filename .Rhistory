if (sum(duplicated(key)) > 0){
stop("Your answer key contains duplicates. Please check your data.")
}
key <- data.frame("Answer" = key, "Tested.Position" = 1:length(key))
#merge that with the data
DF <- as.data.frame(data)
colnames(DF)[grepl(answer, colnames(DF))] <- "Answer"
colnames(DF)[grepl(position, colnames(DF))] <- "Answered.Position"
colnames(DF)[grepl(scored, colnames(DF))] <- "Scored"
DF <- merge(DF, key, by = "Answer")
#calculate the number of times within window
DF$Answered.Position <- as.numeric(DF$Answered.Position)
DF$Tested.Position <- as.numeric(DF$Tested.Position)
DF$Lag <- DF$Tested.Position - DF$Answered.Position
View(DF)
names(DF)
head(DF)
i = "A3SATHBTQSEJKF"
temp_part <- subset(DF,
Sub.ID == i)
View(temp_part)
temp_part <- temp_part[order(DF$Answered.Position)]
temp_part <- temp_part[order(DF$Answered.Position), ]
temp_part <- subset(DF,
Sub.ID == i)
temp_part <- temp_part[order(temp_part$Answered.Position), ]
View(temp_part)
?cumsum
diff(temp_part$Tested.Position)
possible_lags <- diff(temp_part$Tested.Position)
participant_lags <- diff(temp_part$Tested.Position)
possible_lags <- c()
number_spots <- max(DF$Tested.Position)
number_spots
number_spots <- 1:max(DF$Tested.Position)
j = 1
number_spots <- 1:max(DF$Tested.Position)
#take up to the current answered position
current <- temp_part$Answered.Position[1:j]
current
#take up to the current answered position
current <- temp_part$Tested.Position[1:j]
answers_left <- setdiff(current, number_spots)
answers_left
#take up to the current answered position
current <- temp_part$Tested.Position[1:j]
answers_left <- setdiff(current, number_spots)
answers_left
answers_left <- setdiff(number_spots, current)
answers_left
current_spot <- temp_part$Tested.Position[j]
current_spot - answers_left
answers_left - current_spot
j = 3
#take up to the current answered position
current_used <- temp_part$Tested.Position[1:j]
current_used
answers_left <- setdiff(number_spots, current)
answers_left
answers_left <- setdiff(number_spots, current_used)
answers_left
current_spot <- temp_part$Tested.Position[j]
current_spot
answers_left - current_spot
participant_lags <- diff(temp_part$Tested.Position)
participant_lags
#participant lags
for (j in 1:nrow(temp_part)){
#take up to the current answered position
current_used <- temp_part$Tested.Position[1:j]
answers_left <- setdiff(number_spots, current_used)
current_spot <- temp_part$Tested.Position[j]
possible_lags <- c(possible_lags, answers_left - current_spot)
}
possible_lags
table(participant_lags, possible_lags)
table(participant_lags)
table(possible_lags)
table_possible_lags <- table(possible_lags)
table_possible_lags <- as.data.frame(table(possible_lags))
table_possible_lags
table_part_lags
table_part_lag
table_part_lags <- as.data.frame(table(participant_lags))
table_part_lags
colnames(table_possible_lags) <- c("participant_lags", "Possible.Freq")
table_part_lags <- merge(table_part_lags,
table_possible_lags,
by = "participant_lags")
table_part_lags
table_part_lags$Sub.ID <- i
table_part_lags
head(temp_part)
names(DF)
#add back in other columns that are one to one
other.columns <- setdiff(colnames(DF),
c("Responses", "Sub.ID", "Answer", "Scored",
colnames(table_part_lags)))
other.columns
#add back in other columns that are one to one
other.columns <- setdiff(colnames(DF),
c("Responses", "Sub.ID", "Answer",
"Scored", "Answered.Position",
"Tested.Position", "Lag",
colnames(table_part_lags)))
other.columns
for (col in other.columns){
DF_temp <- unique(DF[ , c("Sub.ID", col)])
if (sum(duplicated(DF_temp$Sub.ID)) == 0){
table_part_lags <- merge(table_part_lags, DF_temp, by = "Sub.ID")
}
}
table_part_lags
is.null(DF_final)
exists(DF_final)
DF_final <- table_part_lags
DF_final
DF_final <- rbind(DF_final, table_part_lags)
DF_final
DF_final <- NULL
#for each participant calculate the possible lags
for (i in DF$Sub.ID){
temp_part <- subset(DF,
Sub.ID == i)
temp_part <- temp_part[order(temp_part$Answered.Position), ]
participant_lags <- diff(temp_part$Tested.Position)
possible_lags <- c()
#participant lags
for (j in 1:nrow(temp_part)){
#take up to the current answered position
current_used <- temp_part$Tested.Position[1:j]
answers_left <- setdiff(number_spots, current_used)
current_spot <- temp_part$Tested.Position[j]
possible_lags <- c(possible_lags, answers_left - current_spot)
} #answers loop
table_part_lags <- as.data.frame(table(participant_lags))
table_possible_lags <- as.data.frame(table(possible_lags))
colnames(table_possible_lags) <- c("participant_lags", "Possible.Freq")
table_part_lags <- merge(table_part_lags,
table_possible_lags,
by = "participant_lags")
table_part_lags$Sub.ID <- i
#add back in other columns that are one to one
other.columns <- setdiff(colnames(DF),
c("Responses", "Sub.ID", "Answer",
"Scored", "Answered.Position",
"Tested.Position", "Lag",
colnames(table_part_lags)))
for (col in other.columns){
DF_temp <- unique(DF[ , c("Sub.ID", col)])
if (sum(duplicated(DF_temp$Sub.ID)) == 0){
table_part_lags <- merge(table_part_lags, DF_temp, by = "Sub.ID")
}
} #for other columns
if (is.null(DF_final)){
DF_final <- table_part_lags
} else {
DF_final <- rbind(DF_final, table_part_lags)
}
} #participant loop
table_part_lags
temp_part
View(DF)
participant_lags
DF_final <- NULL
#for each participant calculate the possible lags
for (i in DF$Sub.ID){
temp_part <- subset(DF,
Sub.ID == i)
temp_part <- temp_part[order(temp_part$Answered.Position), ]
participant_lags <- diff(temp_part$Tested.Position)
possible_lags <- c()
if (nrow(temp_part) > 1){
#participant lags
for (j in 1:nrow(temp_part)){
#take up to the current answered position
current_used <- temp_part$Tested.Position[1:j]
answers_left <- setdiff(number_spots, current_used)
current_spot <- temp_part$Tested.Position[j]
possible_lags <- c(possible_lags, answers_left - current_spot)
} #answers loop
table_part_lags <- as.data.frame(table(participant_lags))
table_possible_lags <- as.data.frame(table(possible_lags))
colnames(table_possible_lags) <- c("participant_lags", "Possible.Freq")
table_part_lags <- merge(table_part_lags,
table_possible_lags,
by = "participant_lags")
table_part_lags$Sub.ID <- i
#add back in other columns that are one to one
other.columns <- setdiff(colnames(DF),
c("Responses", "Sub.ID", "Answer",
"Scored", "Answered.Position",
"Tested.Position", "Lag",
colnames(table_part_lags)))
for (col in other.columns){
DF_temp <- unique(DF[ , c("Sub.ID", col)])
if (sum(duplicated(DF_temp$Sub.ID)) == 0){
table_part_lags <- merge(table_part_lags, DF_temp, by = "Sub.ID")
}
} #for other columns
if (is.null(DF_final)){
DF_final <- table_part_lags
} else {
DF_final <- rbind(DF_final, table_part_lags)
}
} #must have more than one row
} #participant loop
View(DF_final)
DF_final$CRP <- DF_final$Freq / DF_final$Possible.Freq
View(DF_final)
View(DF
)
DF_test <- read.csv("data/free_data.csv")
DF_answer <- read.csv("data/answer_key_free2.csv")
colnames(DF_answer)[1] <- "Answer_Key" #Remove weird characters
source("R/prop_correct_free.R")
source("R/arrange_data.R")
DF_test <- subset(DF_test,
List_Type == "Cat_Recall_L1")
DF_long <- arrange_data(responses = DF_test$Response,
sep = " ",
id = DF_test$Username,
other = DF_test$Version,
other.names = "Version")
scored_output <- prop_correct_free( data = DF_long,
responses = "response",
key = DF_answer$Answer_Key,
id = "Sub.ID",
cutoff = 1,
flag = TRUE,
group.by = "Version")
key = DF_answer$Answer_Key
data = scored_output$DF_Scored
position = "position"
scored = "Scored"
answer = "Answer"
group.by = "Version"
source("R/serial_position.R")
serial_output <- serial_position(data = scored_output$DF_Scored,
key = DF_answer$Answer_Key,
position = "position",
scored = "Scored",
answer = "Answer",
group.by = "Version")
head(serial_output)
View(serial_output)
View(data)
DF_test <- read.csv("data/free_data.csv")
DF_answer <- read.csv("data/answer_key_free2.csv")
colnames(DF_answer)[1] <- "Answer_Key" #Remove weird characters
source("R/prop_correct_free.R")
source("R/arrange_data.R")
DF_test <- subset(DF_test,
List_Type == "Cat_Recall_L1")
DF_long <- arrange_data(responses = DF_test$Response,
sep = " ",
id = DF_test$Username,
other = DF_test$Version,
other.names = "Version")
scored_output <- prop_correct_free( data = DF_long,
responses = "response",
key = DF_answer$Answer_Key,
id = "Sub.ID",
cutoff = 1,
flag = TRUE,
group.by = "Version")
source("R/crp.R")
names(scored_output$DF_Scored)
source('~/GitHub/2.5 packages/lrd/tests/test crp.R', echo=TRUE)
crp_output <- crp(data = scored_output$DF_Scored,
position = "position",
answer = "Answer",
id = "Sub.ID",
key = DF_answer$Answer_Key,
scored = "Scored")
head(crp_output)
View(serial_output)
#create answer key with order
if (sum(duplicated(key)) > 0){
stop("Your answer key contains duplicates. Please check your data.")
}
key <- data.frame("Answer" = key, "Tested.Position" = 1:length(key))
#merge that with the data
DF <- as.data.frame(data)
colnames(DF)[grepl(answer, colnames(DF))] <- "Answer"
colnames(DF)[grepl(position, colnames(DF))] <- "Answered.Position"
colnames(DF)[grepl(scored, colnames(DF))] <- "Scored"
colnames(DF)[grepl(id, colnames(DF))] <- "Sub.ID"
DF <- merge(DF, key, by = "Answer")
#calculate the number of times within window
DF$Answered.Position <- as.numeric(DF$Answered.Position)
DF$Tested.Position <- as.numeric(DF$Tested.Position)
View(DF)
DF_first <- subset(DF, Answered.Position == 1)
View(DF_first)
pfr_table <- table(DF_first$Test)
pfr_table <- table(DF_first$Tested.Position)
pfr_table
group.by
if(!is.null(group.by)){
pfr_table <- table(DF_first[ , c("Tested.Position", group.by)])
}
pfr_table
pfr_table <- as.data.frame(table(DF_first[ , c("Tested.Position", group.by)]))
pfr_table
DF_unique <- unique(DF[ , c("Sub.ID", group.by)])
group_sizes <- as.data.frame(table(DF_unique[ , group.by]))
group_sizes$group_code <- paste(group_sizes[ , -ncol(group_sizes)])
group_code <- paste(pfr_table[ , group.by])
pfr_table$pfr <- NA
for (group in group_code){
pfr_table$pfr[group_code == group] <- pfr_table$Freq[group_code == group] / group_sizes$Freq[group_sizes$group_code == group]
}
View(pfr_table)
names(pfr_table)
DF_test <- read.csv("data/free_data.csv")
DF_answer <- read.csv("data/answer_key_free2.csv")
colnames(DF_answer)[1] <- "Answer_Key" #Remove weird characters
source("R/prop_correct_free.R")
source("R/arrange_data.R")
DF_test <- subset(DF_test,
List_Type == "Cat_Recall_L1")
DF_long <- arrange_data(responses = DF_test$Response,
sep = " ",
id = DF_test$Username,
other = DF_test$Version,
other.names = "Version")
scored_output <- prop_correct_free( data = DF_long,
responses = "response",
key = DF_answer$Answer_Key,
id = "Sub.ID",
cutoff = 1,
flag = TRUE,
group.by = "Version")
source("R/pfr.R")
pfr_output <- pfr(data = scored_output$DF_Scored,
position = "position",
answer = "Answer",
id = "Sub.ID",
key = DF_answer$Answer_Key,
scored = "Scored",
group.by = "Version")
head(pfr_output)
colnames(DF
)
c("Responses", "Sub.ID", "Answer",
"Scored", "Answered.Position",
"Tested.Position",
colnames(pfr_table))
#add back in other columns that are one to one
other.columns <- setdiff(colnames(DF),
c("Responses", "Sub.ID", "Answer",
"Scored", "Answered.Position",
"Tested.Position",
colnames(pfr_table)))
other.columns
crp_output
View(crp_output)
check()
library(devtools)
check()
roxygen2::roxygenise()
check()
check()
check()
roxygen2::roxygenise()
check()
roxygen2::roxygenise()
check()
check()
corpus = "en"
gzcon(url(paste("https://rb.gy/eabzqf.", corpus, ".gz", sep="")))
check()
roxygen2::roxygenise()
check()
roxygen2::roxygenise()
check()
load("~/GitHub/2.5 packages/lrd/data/wide_data.RData")
View(wide_data)
data(mtcars)
View(mtcars)
library(devtools)
check()
data(mtcars)
View(mtcars)
load("data/wide_data.RData")
save(wide_data, "data/wide_data.RData")
?save
save(wide_data, file =  "data/wide_data.RData")
getwd()
check()
load("data/wide_data.RData")
ls
ls()
load("data/wide_data.RData")
str(wide_data)
wide_data <- read.csc("data/wide_data.csv")
wide_data <- read.csv("data/wide_data.csv")
wide_data <- read.csv("data/wide_data.csv")
save(wide_data, file = "wide_data.RData")
roxygen2::roxygenise()
check()
wide_data <- rio::import("wide_data.xlsx")
save(wide_data, file = "wide_data.RData")
roxygen2::roxygenise()
check()
check()
roxygen2::roxygenise()
check()
data("data/free_data.RData")
load("/Users/buchanan/GitHub/2.5 packages/lrd/data/free_data.RData")
data("wide_data.RData")
data(wide_data)
roxygen2::roxygenise()
check()
data(wide_data)
DF_long <- arrange_data(
data = wide_data,
responses = "Response",
sep = ",",
id = "Sub.ID")
head(DF_long)
data(free_data)
names(free_data)
free_data <- subset(free_data,
List_Type == "Cat_Recall_L1")
DF_long <- arrange_data(data = free_data,
responses = "Response",
sep = " ",
id = "Username")
data = free_data
responses = "Response"
sep = " "
id = "Username"
#get the data
data <- as.data.frame(data)
#split the strings, returns a list
answers <- strsplit(data[ , responses], split = sep)
#list to long
df <- data.frame(response = unlist(answers))
#take out any extra spaces
df$response <- gsub("\\s+", " ", df$response)
df$response <- trimws(df$response, "both")
#add participant id
df$Sub.ID <- rep(data[ , id], unlist(lapply(answers, length)))
#add position tag
df$position <- ave(df$Sub.ID, df$Sub.ID, FUN = seq_along)
#add back in other columns that are one to one
other.columns <- setdiff(colnames(data),
c("response", "Sub.ID", "position", responses))
for (col in other.columns){
data_temp <- unique(data[ , c("Sub.ID", col)])
if (sum(duplicated(data$Sub.ID)) == 0){
df <- merge(df, data_temp, by = "Sub.ID")
}
}
names(data)
other.columns
names(DF)
names(DF)
names(df)
#add back in other columns that are one to one
other.columns <- setdiff(colnames(data),
c("response", "Sub.ID", "position", responses))
other.columns
roxygen2::roxygenise()
roxygen2::roxygenise()
check()
data(free_data)
free_data <- subset(free_data,
List_Type == "Cat_Recall_L1")
data = free_data
responses = "Response"
sep = " "
id = "Username"
#get the data
data <- as.data.frame(data)
colnames(data)[grepl(id, colnames(data))] <- "Sub.ID"
names(data)
#split the strings, returns a list
answers <- strsplit(data[ , responses], split = sep)
#list to long
df <- data.frame(response = unlist(answers))
#take out any extra spaces
df$response <- gsub("\\s+", " ", df$response)
df$response <- trimws(df$response, "both")
#add participant id
df$Sub.ID <- rep(data[ , id], unlist(lapply(answers, length)))
#add participant id
df$Sub.ID <- rep(data$Sub.ID, unlist(lapply(answers, length)))
#add position tag
df$position <- ave(df$Sub.ID, df$Sub.ID, FUN = seq_along)
#add back in other columns that are one to one
other.columns <- setdiff(colnames(data),
c("response", "Sub.ID", "position", responses))
for (col in other.columns){
data_temp <- unique(data[ , c("Sub.ID", col)])
if (sum(duplicated(data$Sub.ID)) == 0){
df <- merge(df, data_temp, by = "Sub.ID")
}
}
library(roxygen2)
roxygenise()
roxygenise()
check()
roxygenise()
check()
install_github("npm27/lrd")
data(wide_data)
roxygenize()
check()
install_github("npm27/lrd")
