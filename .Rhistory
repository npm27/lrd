##calculate MSE for Recall
r.mse = model2$ANOVA$SSd[2]/model2$ANOVA$DFd[2]
jol.mse;r.mse
##get dfn (mean)
dfn.jol = model1$ANOVA$DFn[2]
dfn.r = model2$ANOVA$DFn[2]
##get dfd (error)
dfd.jol = model1$ANOVA$DFd[2]
dfd.r = model2$ANOVA$DFd[2]
##get ssn (mean)
ssn.jol = model1$ANOVA$SSn[2]
ssn.r = model2$ANOVA$SSn[2]
##get ssd (error)
ssd.jol = model1$ANOVA$SSd[2]
ssd.r = model2$ANOVA$SSd[2]
##get F
fstat.jol = model1$ANOVA$F[2]
fstat.r = model2$ANOVA$F[2]
####post hoc t-tests####
##JOL
pairwise.t.test(nomiss$Jol, nomiss$Direction, ##significant difference between Unrelated pairs and related pairs
paired = F, p.adjust.method = 'none')
##Recall
pairwise.t.test(nomiss$Recall, nomiss$Direction, ##all are significant
paired = F, p.adjust.method = 'none')
##get t values for post hocs
source("pairwise_t.R")
Jol.t = pairwise.t.test.with.t.and.df(nomiss$Jol, nomiss$Direction,
paired = F, p.adjust.method = 'none')
Jol.t
print(Jol.t)[[5]] #T-values
print(Jol.t)[[6]] #df
R.t = pairwise.t.test.with.t.and.df(nomiss$Recall, nomiss$Direction,
paired = F, p.adjust.method = 'none')
R.t
print(R.t)[[5]] #T-values
print(R.t)[[6]] #df
model1
model2
meanJol = tapply(nomiss$Jol, nomiss$Direction, mean)
meanR = tapply(nomiss$Recall, nomiss$Direction, mean)
meanJol
sdJol
meanR = tapply(nomiss$Recall, nomiss$Direction, mean)
sdR = tapply(nomiss$Recall, nomiss$Direction, sd, na.rm = T)
sdR
meanR
nJol = tapply(nomiss$Jol, nomiss$Direction, length)
nR = tapply(nomiss$Recall, nomiss$Direction, length)
meanR;sdR;nR
jfb = d.dep.t.avg(68.20625, 66.08839, 28.41285, 28.81500, 1120, a = .05) #d = .07
jfb.d = round(jfb$d, digits = 2)
jfb.d
print(R.t)[[5]] #T-values
pairwise.t.test(nomiss$Jol, nomiss$Direction, ##significant difference between Unrelated pairs and related pairs
paired = F, p.adjust.method = 'Bonferroni')
pairwise.t.test(nomiss$Jol, nomiss$Direction, ##significant difference between Unrelated pairs and related pairs
paired = F, p.adjust.method = 'bonferroni')
pairwise.t.test(nomiss$Recall, nomiss$Direction, ##all are significant
paired = F, p.adjust.method = 'bonferroni')
Jol.t = pairwise.t.test.with.t.and.df(nomiss$Jol, nomiss$Direction,
paired = F, p.adjust.method = 'bonferroni')
R.t = pairwise.t.test.with.t.and.df(nomiss$Recall, nomiss$Direction,
paired = F, p.adjust.method = 'bonferroni')
print(Jol.t)[[5]] #T-values
print(R.t)[[5]] #T-values
rfs = d.dep.t.avg(67.40741, 58.83929, 46.89169, 49.23445, 1120, a = .05) #d = 0.18
rfs.d = round(rfs$d, digits = 2)
rfs.d
model9 = aov(int.dat$diff ~ (int.dat$jol_bin*int.dat$direction))
nomiss.f = subset(nomiss,
nomiss$Direction == "F")
nomiss.b = subset(nomiss,
nomiss$Direction == "B")
nomiss.s = subset(nomiss,
nomiss$Direction == "S")
nomiss.u = subset(nomiss,
nomiss$Direction == "U")
##get rounded jols
nomiss.f$jol_bin = round(nomiss.f$Jol, -1)
nomiss.b$jol_bin = round(nomiss.b$Jol, -1)
nomiss.s$jol_bin = round(nomiss.s$Jol, -1)
nomiss.u$jol_bin = round(nomiss.u$Jol, -1)
##put data in wide format
##jol
f.jol = cast(nomiss.f, Subject ~ block, mean, value = 'Jol')
f.jol$mean_JOL = apply(f.jol, 1, mean)
f.jol$jol_bin = round(f.jol$mean_JOL, -1)
b.jol = cast(nomiss.b, Subject ~ block, mean, value = 'Jol')
b.jol$mean_JOL = apply(b.jol, 1, mean)
b.jol$jol_bin = round(b.jol$mean_JOL, -1)
s.jol = cast(nomiss.s, Subject ~ block, mean, value = 'Jol')
s.jol$mean_JOL = apply(s.jol, 1, mean)
s.jol$jol_bin = round(s.jol$mean_JOL, -1)
u.jol = cast(nomiss.u, Subject ~ block, mean, value = 'Jol')
u.jol$mean_JOL = apply(u.jol, 1, mean)
u.jol$jol_bin = round(u.jol$mean_JOL, -1)
##recall
f.recall = cast(nomiss.f, Subject ~ block, mean, value = 'Recall')
f.recall$mean_recall = apply(f.recall, 1, mean)
b.recall = cast(nomiss.b, Subject ~ block, mean, value = 'Recall')
b.recall$mean_recall = apply(b.recall, 1, mean)
s.recall = cast(nomiss.s, Subject ~ block, mean, value = 'Recall')
s.recall$mean_recall = apply(s.recall, 1, mean)
u.recall = cast(nomiss.u, Subject ~ block, mean, value = 'Recall')
u.recall$mean_recall = apply(u.recall, 1, mean)
##add direction column
f.recall$direction = rep("f", 28)
f.jol$direction = rep("f", 28)
b.recall$direction = rep("b", 28)
b.jol$direction = rep("b", 28)
s.recall$direction = rep("s", 28)
s.jol$direction = rep("s", 28)
u.recall$direction = rep("u", 28)
u.jol$direction = rep("u", 28)
##Put everything back together
int.recall = rbind(f.recall, b.recall, s.recall, u.recall)
int.jol = rbind(f.jol, b.jol, s.jol, u.jol)
int.recall = int.recall[ , -c(2:3)]
int.jol = int.jol[ , -c(2:3)]
int.dat = cbind(int.jol, int.recall)
int.dat = int.dat[ , -c(4:5)]
##get difference score
int.dat$mean_recall = int.dat$mean_recall * 100
int.dat$diff = int.dat$jol_bin - int.dat$mean_recall
library(car)
model9 = aov(int.dat$diff ~ (int.dat$jol_bin*int.dat$direction))
summary(model9)
library(lsr)
etas1 = etaSquared(model9)
bar3 = ggplot(long.dat, aes(Direction, Score, fill = Task))
bar3 = bar3 +
stat_summary(fun.y = mean,
geom = "bar",
position = "dodge",
color = "Black") +
stat_summary(fun.data = mean_cl_normal,
geom = "errorbar",
position = position_dodge(width = 0.90),
width = 0.2,
color = "black") +
scale_fill_manual("Task",
values = c("Jol" = "white",
"Recall" = "dimgrey")) +
cleanup +
xlab("Direction") +
ylab("Mean Task Performance")
ylim(0,100)
#labs(title="All Blocks")
bar3
dat = read.csv("ex2 final output.csv")
summary(dat)
library(ggplot2)
library(reshape)
##put recall on correct scale
dat$Scored_Response = (dat$Scored_Response * 100)
##remove out of range scores
dat$Jol_Response[dat$Jol_Response > 100] = NA
##get sample size
summary(dat$Subject) #n = 34
summary(dat)
##remove missing
nomiss3 = na.omit(dat)
colnames(nomiss3)[6] = "Jol"
colnames(nomiss3)[9] = "Recall"
####make the graph####
##melt the data
long.dat = melt(nomiss3, id = c("Subject", "Block",
"ListNum", "Direction", "ExperimentName", "cue_target",
"recall_response", "cue_prompt"))
summary(long.dat)
colnames(long.dat)[9] = "Task"
colnames(long.dat)[10] = "Score"
bar3 = ggplot(long.dat, aes(Direction, Score, fill = Task))
bar3 = bar3 +
stat_summary(fun.y = mean,
geom = "bar",
position = "dodge",
color = "Black") +
stat_summary(fun.data = mean_cl_normal,
geom = "errorbar",
position = position_dodge(width = 0.90),
width = 0.2,
color = "black") +
scale_fill_manual("Task",
values = c("Jol" = "white",
"Recall" = "dimgrey")) +
cleanup +
xlab("Direction") +
ylab("Mean Task Performance")
ylim(0,100)
#labs(title="All Blocks")
bar3
bar3 = ggplot(long.dat, aes(Direction, Score, fill = Task))
bar3 = bar3 +
stat_summary(fun.y = mean,
geom = "bar",
position = "dodge",
color = "Black") +
stat_summary(fun.data = mean_cl_normal,
geom = "errorbar",
position = position_dodge(width = 0.90),
width = 0.2,
color = "black") +
scale_fill_manual("Task",
values = c("Jol" = "white",
"Recall" = "dimgrey")) +
cleanup +
xlab("Direction") +
ylab("Mean Task Performance") +
ylim(0,100)
#labs(title="All Blocks")
bar3
knitr::include_graphics("plot1.png")
citr:::insert_citation()
12.11*40
484.4*2
968.8*.15
968.8-145.32
823-110-50
85-22)
85-22
n = 100
dbinom(100)
dbinom(50, 100, 50)
dbinom(50, 100, 2)
dbinom(50, 100, .5)
dbinom(50, 100, .5)
round(data.frame(0:100, probs), digits = 5)
probs = dbinom(50, 100, .5)
round(data.frame(0:100, probs), digits = 5)
plot(0:100, probs, type="h", xlim=c(0,100), ylim=c(0,.1))
probs = dbinom(0:100, 100, .5) ##get the probability
round(data.frame(0:100, probs), digits = 5)
plot(0:100, probs, type="h", xlim=c(0,100), ylim=c(0,.1))
points(0:100, probs, pch=16, cex=.5)
curve(dnorm(x, mean=50, sd=5), from=0, to=100, xlim = c(0, 100), ylim = c(0, 0.5), xlab = "x", add=T, col="blue")
sum(dbinom(45:55, size=100, prob=1/2))
sum(dbinom(50, size=100, prob=1/2))
length(probs)
probs = as.data.frame(probs)
subset(probs, Mod(probs$probs) == 0)
View(probs)
head = 1
tail = 0
prob = e
e
e = exp(1)
sample(c("Heads", "Tails"), n, rep = T)
Flip1Coin = function(n) sample(c("Heads", "Tails"), n, rep = T)
Flip1Coin(n)
sample(c("Heads", "Tails"), n, rep = T)
sample(c("Heads", "Tails"), n, rep = 100)
Flip1Coin = function(n) sample(c("Heads", "Tails"), n, rep = 100)
Flip1Coin(n)
sample(c("Heads", "Tails"), n, rep = 100)
Flip1Coin = sample(c("Heads", "Tails"), n, rep = 100)
pbinom(50, 100, .5)
dbinom(50, 100, .5)
dnorm(50)
dnorm(50/sqrt(24))
pbinom(50, size = 100, .5)
pbinom(48, size = 100, .5)
pbinom(52, size = 100, .5)
pbinom(71, size = 100, .5)
m = 100 * .5
sd1 = sqrt(100 * .5 *.5)
1 - dnorm(50, mean = m, sd = sd1)
1 - pnorm(50, mean = m, sd = sd1)
x = c(0:100)
length(x)
mod(x, 2)
Mod(x)
Mod(x, 2)
setwd("~/GitHub/lrd/Test Data")
5500+500+600+3500+10000+2000
22100 / (590+250+100+100+50+50+150+100)
(22100 + 800 + 800 + 800 + 480 + 2400) / (590+250+100+100+50+50+150+100)
(22100 + 800 + 800 + 800 + 480 + 2400 + 300+ 700) / (590+250+100+100+50+50+150+100)
setwd("~/GitHub/lrd")
shiny::runApp('~/lrd')
runApp('~/lrd')
ui <- fluidPage(
fluidPage(
titlePanel("Uploading Files"),
sidebarLayout(
sidebarPanel(
fileInput('file1', 'Choose CSV File',
accept=c('text/csv',
'text/comma-separated-values,text/plain',
'.csv')),
tags$hr(),
checkboxInput('header', 'Header', TRUE),
radioButtons('sep', 'Separator',
c(Comma=',',
Semicolon=';',
Tab='\t'),
','),
radioButtons('quote', 'Quote',
c(None='',
'Double Quote'='"',
'Single Quote'="'"),
'"'),
downloadButton('downloadData', 'Download')
),
mainPanel(
tableOutput('contents')
)
)
)
)
runApp('~/lrd')
runApp('~/lrd')
runApp('~/lrd')
runApp('~/lrd')
runApp('~/lrd')
runApp('~/lrd')
runApp('~/lrd')
runApp('~/lrd')
runApp('~/lrd')
runApp('~/lrd')
runApp()
runApp('~/lrd')
runApp('~/lrd')
runApp('~/lrd')
Score_Recall = function(x, weight = FALSE, set.cutoff = y){
if (weight == FALSE){
x$scored = as.numeric(x$percent_match >= set.cutoff)
x$scored[is.na(x$scored)] = 0
}
else if (weight == TRUE){
x$scored = as.numeric(x$weighted_match >= set.cutoff)
x$scored[is.na(x$scored)] = 0
}
Score_Recall(matched, set.cutoff = .75)
}
runApp('~/lrd')
runApp('~/lrd')
runApp('~/lrd')
runApp('~/lrd')
runApp('~/lrd')
runApp('~/lrd')
runApp('~/lrd')
#####load libraries and custom functions####
library(shiny)
Percent_Match = function(x, key = y, id = z, weight = FALSE, weight.by = NULL){
xx = weight.by
input = data.frame(id, x, key)
input$id = as.character(input$id)
input$x = as.character(input$x)
input$key = as.character(input$key)
input$length_x = nchar(input$x)
input$length_key = nchar(input$key)
input$diff = input$length_x - input$length_key
sub1 = subset(input,
input$diff >= 1)
sub2 = subset(input,
input$diff == 0)
sub3 = subset(input,
input$diff < 0)
sub1 = sub1[ , -c(4:6)]
sub2 = sub2[ , -c(4:6)]
sub3 = sub3[ , -c(4:6)]
char.x1 = vector(mode = "character", length = nrow(sub1))
char.x2 = vector(mode = "character", length = nrow(sub2))
char.x3 = vector(mode = "character", length = nrow(sub3))
char.y1 = vector(mode = "character", length = nrow(sub1))
char.y2 = vector(mode = "character", length = nrow(sub2))
char.y3 = vector(mode = "character", length = nrow(sub3))
percent_match1 = vector(mode = "character", length = nrow(sub1))
percent_match2 = vector(mode = "character", length = nrow(sub2))
percent_match3 = vector(mode = "character", length = nrow(sub3))
for (i in 1:nrow(sub1)) {
char.x1[i] = strsplit(sub1$x[i], "")
char.y1[i] = strsplit(sub1$key[i], "")
}
for (k in 1:nrow(sub1)) {
c = char.x1[[k]]
d = char.y1[[k]]
percent_match1[k] = length(na.omit(d[is.element(c, d)])) /
length(c)
sub1$percent_match = percent_match1
}
for (h in 1:nrow(sub2)) {
char.x2[h] = strsplit(sub2$x[h], "")
char.y2[h] = strsplit(sub2$key[h], "")
}
for (j in 1:nrow(sub2)) {
e = char.x2[[j]]
f = char.y2[[j]]
percent_match2[j] = length(na.omit(f[is.element(e, f)])) /
length(e)
sub2$percent_match = percent_match2
}
for (q in 1:nrow(sub3)) {
char.x3[q] = strsplit(sub3$x[q], "")
char.y3[q] = strsplit(sub3$key[q], "")
}
for (p in 1:nrow(sub3)) {
r = char.x3[[p]]
s = char.y3[[p]]
percent_match3[p] = length(unique(r[r %in% s[s %in% r]])) /
length(s)
sub3$percent_match = percent_match3
}
output = rbind(sub1, sub2, sub3)
output = output[order(as.numeric(rownames(output))),,drop = FALSE]
output$Scored = as.numeric(output$percent_match >= .75)
if (weight == TRUE){
if (weight.by <= 1 & is.null(weight.by) == FALSE){
sub4 = subset(output,
output$percent_match == 1)
sub5 = subset(output,
output$percent_match == 0)
sub6 = subset(output,
output$percent_match < 1 & output$percent_match > 0)
sub4$weighted_match = as.numeric(sub4$percent_match)
sub5$weighted_match = as.numeric(sub5$percent_match)
sub6$weighted_match = as.numeric(sub6$percent_match) + (weight.by / nchar(sub6$key))
output2 = rbind(sub4, sub5, sub6)
output2 = output2[order(as.numeric(rownames(output2))),,drop = FALSE]
print(output2)
}
else if (is.null(weight.by) == FALSE & weight.by > 1) {
print("weight.by must be a value between 0 and 1!")
}
}
else if (weight == FALSE) {
print(output)
}
}
####Set up page####
ui = fluidPage(
fluidPage(
titlePanel("Uploading Files"),
sidebarLayout(
sidebarPanel(
fileInput('file1', 'Choose CSV File',
accept = c('text/csv',
'text/comma-separated-values,text/plain',
'.csv')),
tags$hr(),
checkboxInput('header', 'Header', TRUE),
radioButtons('sep', 'Separator',
c(Comma = ',',
Semicolon = ';',
Tab ='\t'),
','),
radioButtons('quote', 'Quote',
c(None ='',
'Double Quote'= '"',
'Single Quote'= "'"),
'"'),
downloadButton('downloadData', 'Download')
),
mainPanel(
helpText("Note: Input data must contain three columns arranged in the following order:",
"A unique participant identifier, participant resopnses, a scoring key.",
"After uploading your file, the scored data will be displayed below."),
tableOutput('contents')
)
)
)
)
####Set up server####
server = function(input, output) {
getData = reactive({
inFile = input$file1
if (is.null(input$file1))
return(NULL)
dat = read.csv(inFile$datapath, header = input$header, sep = input$sep,
quote = input$quote)
##use lrd to process the output
colnames(dat)[1:3] = c("ID", "Response", "Key")
dat$Response = tolower(dat$Response)
dat$Key = tolower(dat$Key)
Percent_Match(dat$Response, key = dat$Key, id = dat$ID)
#dat$Scored = as.numeric(matched$percent_match >= .75)
}
)
output$contents = renderTable(
getData()
)
output$downloadData = downloadHandler(
filename = function() {
paste("data-", Sys.Date(), ".csv", sep = "")
},
content = function(file) {
write.csv(getData(), file)
})
}
# Run the app ----
shinyApp(ui, server)
install.packages("resconnect")
install.packages("rsconnect")
rsconnect::setAccountInfo(name='npm27',
token='857D9C76CFF94C26E71BE4E6A98ED9AD',
secret='e+cE4Qo5ydL3u/uDoa4jzy1a+qM5GEuhnSyiZ39N')
rsconnect::deployApp('C:\Users\nickm.000\Documents\lrd')
rsconnect::deployApp('C:/Users/nickm.000/Documents/lrd')
rsconnect::deployApp('C:/Users/nickm.000/Documents/lrdSHINY/lrdshiny.R')
rsconnect::deployApp('C:/Users/nickm.000/Documents/lrdSHINY/lrdshiny.R')
rsconnect::deployApp('C:/Users/nickm.000/Documents/lrdSHINY')
rsconnect::deployApp('C:/Users/nickm.000/Documents/lrdSHINY')
runApp('~/lrdSHINY')
runApp('~/lrdSHINY')
runApp('~/lrdSHINY')
#install.packages("rsconnect")
rsconnect::setAccountInfo(name = 'npm27',
token = '857D9C76CFF94C26E71BE4E6A98ED9AD',
secret = 'e+cE4Qo5ydL3u/uDoa4jzy1a+qM5GEuhnSyiZ39N')
rsconnect::deployApp('C:/Users/nickm.000/Documents/lrdSHINY')
