head(DF_long)
multi_answers <- tolower(multi_answers)
View(multi_answers)
answer_long <- melt(multi_answers)
library(reshape)
answer_long <- melt(multi_answers)
View(answer_long)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(lrd)
data("multi_data")
head(multi_data)
#?multi_data
data("multi_answers")
head(multi_answers)
#?multi_answers
library(ggplot2)
library(reshape)
DF_long <- arrange_data(data = multi_data,
responses = "Response",
sep = " ",
id = "Sub.ID",
repeated = "List.Number")
head(DF_long)
answer_long <- melt(multi_answers)
head(answer_long)
answer_long <- melt(multi_answers,
measured = colnames(multi_answers))
head(answer_long)
colnames(multi_answers)
answer_long <- melt(multi_answers,
measured = colnames(multi_answers),
id = 1:nrow(multi_answers))
answer_long$row <- 1:nrow(multi_answers)
answer_long <- melt(multi_answers,
measured = colnames(multi_answers),
id = row)
row
multi_answers$row_id <- 1:nrow(multi_answers)
answer_long <- melt(multi_answers,
measured = colnames(multi_answers),
id = row_id)
names(multi_answers)
answer_long <- melt(multi_answers,
measured = colnames(multi_answers),
id = "row_id")
head(answer_long)
View(answer_long)
multi_answers$position <- 1:nrow(multi_answers)
answer_long <- melt(multi_answers,
measured = colnames(multi_answers),
id = "position")
head(answer_long)
data("multi_answers")
multi_answers$position <- 1:nrow(multi_answers)
answer_long <- melt(multi_answers,
measured = colnames(multi_answers),
id = "position")
head(answer_long)
colnames(answer_long) <- c("position", "List.ID", "Answer")
head(answer_long)
#match list id to participant data, which is only numbers
answer_long$List.ID <- gsub(pattern = "List",
replacment = " ",
x = answer_long$List.ID)
#match list id to participant data, which is only numbers
answer_long$List.ID <- gsub(pattern = "List",
replacement = "",
x = answer_long$List.ID)
head(answer_long)
DF_long$response <- tolower(DF_long$response)
answer_long$Answer <- tolower(answer_long$Answer)
View(DF_long)
View(answer_long)
names(DF_long)
data = DF_long
data
responses = "response"
key = answer_long$Answer
key.trial = answer_long$List.ID
id = "Sub.ID"
id.trial = "List.Number"
cutoff = 1
flag = TRUE
#get list IDs
list_ids <- unique(data[ , key.trial])
key.trial
#get list IDs
list_ids <- unique(data[ , id.trial])
list_ids
split(data, list_ids)
temp <- split(data, data[ , id.trial])
View(temp)
#split the data based on ID
data_list <- split(data, data[ , id.trial])
?lapply
?prop_correct_free
#create a storage space
scored_data <- list(1:length(data_list))
str(scored_Data)
str(scored_data)
#create a storage space
scored_data <- list()
scored_data[[1]] <- data_list[[1]]
scored_data
str(scored_data)
#create a storage space
scored_data <- list()
answer_list <- split(data.frame("Answers" = key, "List.ID" = key.trial),
"List.ID")
View(answer_list)
answer_key <- data.frame("Answers" = key, "List.ID" = key.trial)
View(answer_key)
answer_list <- split(answer_key, answer_key$List.ID)
View(answer_list)
#create a storage space for the final scored data
scored_data <- list()
responses
i = 1
answer_list[[i]]$Answers
id
data_list[[i]][[id]]
id
cutoff
flag
group.by  = NULL
woo <- prop_correct_free(data = data_list[[i]],
responses = responses,
key = answer_list[[i]]$Answers,
id = id,
cutoff = cutoff,
flag = flag,
group.by = group.by)
View(woo)
woo[["DF_Scored"]]
View(data)
View(multi_data)
scored_data[[i]] <- prop_correct_free(data = data_list[[i]],
responses = responses,
key = answer_list[[i]]$Answers,
id = id,
cutoff = cutoff,
flag = flag,
group.by = group.by)
View(scored_data)
#run the function on each list separately
for (i in 1:length(data_list)){
scored_data[[i]] <- prop_correct_free(data = data_list[[i]],
responses = responses,
key = answer_list[[i]]$Answers,
id = id,
cutoff = cutoff,
flag = flag,
group.by = group.by)
}
View(scored_data)
scored_data
View(scored_data)
scored_data[[6]][["DF_Participant"]]
scored_data[[6]][["DF_Scored"]]
#recreate the data
participants <- lapply(scored_data, `[[`, 1)
View(participants)
View(scored_data)
#recreate the data
DF_Scored <- lapply(scored_data, `[[`, 1)
DF_Participants <- lapply(scored_data, `[[`, 2)
library(roxygen2)
roxygenize()
devtools::install_github("npm27/lrd")
library(lrd)
data("multi_data")
head(multi_data)
#?multi_data
data("multi_answers")
head(multi_answers)
#?multi_answers
library(ggplot2)
library(reshape)
DF_long <- arrange_data(data = multi_data,
responses = "Response",
sep = " ",
id = "Sub.ID",
repeated = "List.Number")
head(DF_long)
multi_answers$position <- 1:nrow(multi_answers) #this column is only to reshape
answer_long <- melt(multi_answers,
measured = colnames(multi_answers),
id = "position")
#fix columns
colnames(answer_long) <- c("position", "List.ID", "Answer")
#match list id to participant data, which is only numbers
#list IDs can be characters or numbers
answer_long$List.ID <- gsub(pattern = "List",
replacement = "",
x = answer_long$List.ID)
head(answer_long)
DF_long$response <- tolower(DF_long$response)
answer_long$Answer <- tolower(answer_long$Answer)
free_output <- prop_correct_multiple(data = DF_long,
responses = "response",
key = answer_long$Answer,
key.trial = answer_long$List.ID,
id = "Sub.ID",
id.trial = "List.Number",
cutoff = 1,
flag = TRUE)
str(free_output)
roxygenize()
devtools::install_github("npm27/lrd")
free_output <- prop_correct_multiple(data = DF_long,
responses = "response",
key = answer_long$Answer,
key.trial = answer_long$List.ID,
id = "Sub.ID",
id.trial = "List.Number",
cutoff = 1,
flag = TRUE)
str(free_output)
View(free_output)
roxygenize()
devtools::install_github("npm27/lrd")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(lrd)
data("multi_data")
head(multi_data)
#?multi_data
data("multi_answers")
head(multi_answers)
#?multi_answers
library(ggplot2)
library(reshape)
DF_long <- arrange_data(data = multi_data,
responses = "Response",
sep = " ",
id = "Sub.ID",
repeated = "List.Number")
head(DF_long)
multi_answers$position <- 1:nrow(multi_answers) #this column is only to reshape
answer_long <- melt(multi_answers,
measured = colnames(multi_answers),
id = "position")
#fix columns
colnames(answer_long) <- c("position", "List.ID", "Answer")
#match list id to participant data, which is only numbers
#list IDs can be characters or numbers
answer_long$List.ID <- gsub(pattern = "List",
replacement = "",
x = answer_long$List.ID)
head(answer_long)
DF_long$response <- tolower(DF_long$response)
answer_long$Answer <- tolower(answer_long$Answer)
free_output <- prop_correct_multiple(data = DF_long,
responses = "response",
key = answer_long$Answer,
key.trial = answer_long$List.ID,
id = "Sub.ID",
id.trial = "List.Number",
cutoff = 1,
flag = TRUE)
str(free_output)
#Overall
free_output$DF_Scored
#Participant
free_output$DF_Participant
#Group
#free_output$DF_Group
serial_output <- serial_position(data = free_output$DF_Scored,
key = answer_key_free$Answer_Key,
position = "position",
scored = "Scored",
answer = "Answer")
#'
#' serial_output <- serial_position(data = scored_output$DF_Scored,
#'  key = answer_key_free2$Answer_Key,
#'  position = "position",
#'  scored = "Scored",
#'  answer = "Answer",
#'  group.by = "Version")
#'
#'  head(serial_output)
#'
serial_position <- function(data, position, answer,
key, scored, group.by = NULL){
#create answer key with order
if (sum(duplicated(key)) > 0){
stop("Your answer key contains duplicates. Please check your data.")
}
key <- data.frame("Answer" = key, "Tested.Position" = 1:length(key))
#merge that with the data
DF <- as.data.frame(data)
colnames(DF)[grepl(answer, colnames(DF))] <- "Answer"
colnames(DF)[grepl(position, colnames(DF))] <- "Answered.Position"
colnames(DF)[grepl(scored, colnames(DF))] <- "Scored"
DF <- merge(DF, key, by = "Answer")
#calculate the number of times within window
DF$Answered.Position <- as.numeric(DF$Answered.Position)
DF$Tested.Position <- as.numeric(DF$Tested.Position)
DF$Lag <- DF$Tested.Position - DF$Answered.Position
DF$Serial.Yes <- NA
#For the first and last item, you only count if it was first or last
#first position, scored yes, within 0 lag
DF$Serial.Yes[DF$Tested.Position == 1 & DF$Scored == 1 & DF$Lag == 0] <- 1
#last position, same as above
DF$Serial.Yes[DF$Tested.Position == length(key$Answer) &
DF$Scored == 1 & DF$Lag == 0] <- 1
#all others can be + or - 1 away and scored yes
DF$Serial.Yes[DF$Tested.Position > 1 & DF$Tested.Position < length(key$Answer) &
DF$Scored == 1 & abs(DF$Lag) == 1] <- 1
#now aggregate by tested.position and any groups
if (!is.null(group.by)){
DF_serial <- aggregate(DF$Serial.Yes,
by = DF[ , c(group.by, "Tested.Position")],
sum, na.rm = T)
colnames(DF_serial)[ncol(DF_serial)] <- "Freq"
DF_unique <- unique(DF[ , c("Sub.ID", group.by)])
group_sizes <- as.data.frame(table(DF_unique[ , group.by]))
group_sizes$group_code <- paste(group_sizes[ , -ncol(group_sizes)])
group_code <- paste(DF_serial[ , group.by])
DF_serial$Proportion.Correct <- NA
for (group in group_code){
DF_serial$Proportion.Correct[group_code == group] <- DF_serial$Freq[group_code == group] / group_sizes$Freq[group_sizes$group_code == group]
DF_serial$SE[group_code == group] <- sqrt((DF_serial$Proportion.Correct[group_code == group]*(1-DF_serial$Proportion.Correct[group_code == group])/
group_sizes$Freq[group_sizes$group_code == group]))
}
} else {
DF_serial <- aggregate(DF$Serial.Yes,
by = list(DF[ , "Tested.Position"]),
sum, na.rm = T)
colnames(DF_serial) <- c("Tested.Position", "Freq")
group_sizes <- length(unique(DF$Sub.ID))
DF_serial$Proportion.Correct <- DF_serial$Freq / group_sizes
DF_serial$SE <- sqrt((DF_serial$Proportion.Correct*(1-DF_serial$Proportion.Correct)/
group_sizes))
}
return(DF_serial)
}
serial_output <- serial_position(data = free_output$DF_Scored,
key = answer_key_free$Answer_Key,
position = "position",
scored = "Scored",
answer = "Answer")
head(serial_output)
ggplot(serial_output, aes(Tested.Position, Proportion.Correct)) +
geom_line() +
geom_point() +
xlab("Tested Position") +
ylab("Probability of First Response") +
theme_bw()
?serial_position
library(lrd)
?serial_position
??serial_position
ls()
serial_output
free_output
data = free_output$DF_Scored
position = "position"
answer = "Answer"
key = answer_long$Answer
key.trial = answer_long$List.ID
scored = "Scored"
id.trial = "List.Number"
#get list IDs
list_ids <- unique(data[ , id.trial])
list_ids
#split the data based on ID
data_list <- split(data, data[ , id.trial])
View(data_list)
View(data_list)
View(data_list)
data
str(data)
#split the data based on ID
data_list <- split(data, data[ , id.trial])
View(data_list)
View(data_list)
str(data_list)
answer_key <- data.frame("Answers" = key, "List.ID" = key.trial)
answer_list <- split(answer_key, answer_key$List.ID)
answer_list
str(answer_list)
#create a storage space for the final scored data
scored_data <- list()
i = 1
scored_data[[i]] <- serial_position(data = data_list[[i]],
position = position,
answer = answer,
key = answer_list[[i]]$Answers,
scored = scored,
group.by = group.by)
group.by = NULL
scored_data[[i]] <- serial_position(data = data_list[[i]],
position = position,
answer = answer,
key = answer_list[[i]]$Answers,
scored = scored,
group.by = group.by)
View(scored_data)
#run the function on each list separately
for (i in 1:length(data_list)){
scored_data[[i]] <- serial_position(data = data_list[[i]],
position = position,
answer = answer,
key = answer_list[[i]]$Answers,
scored = scored,
group.by = group.by)
}
View(scored_data)
DF_serial <- do.call("rbind", scored_data)
View(DF_serial)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(lrd)
data("multi_data")
head(multi_data)
#?multi_data
data("multi_answers")
head(multi_answers)
#?multi_answers
library(ggplot2)
library(reshape)
DF_long <- arrange_data(data = multi_data,
responses = "Response",
sep = " ",
id = "Sub.ID",
repeated = "List.Number")
head(DF_long)
multi_answers$position <- 1:nrow(multi_answers) #this column is only to reshape
answer_long <- melt(multi_answers,
measured = colnames(multi_answers),
id = "position")
#fix columns
colnames(answer_long) <- c("position", "List.ID", "Answer")
#match list id to participant data, which is only numbers
#list IDs can be characters or numbers
answer_long$List.ID <- gsub(pattern = "List",
replacement = "",
x = answer_long$List.ID)
head(answer_long)
library(roxygen2)
roxygenize()
?crp
?pfr
library(roxygen2)
roxygenize()
devtools::check()
devtools::check()
library(roxygen2)
roxygenize()
devtools::check()
devtools::install_github("npm27/lrd")
library(lrd)
data("multi_data")
head(multi_data)
#?multi_data
data("multi_answers")
head(multi_answers)
#?multi_answers
library(ggplot2)
library(reshape)
DF_long <- arrange_data(data = multi_data,
responses = "Response",
sep = " ",
id = "Sub.ID",
repeated = "List.Number")
head(DF_long)
multi_answers$position <- 1:nrow(multi_answers) #this column is only to reshape
answer_long <- melt(multi_answers,
measured = colnames(multi_answers),
id = "position")
#fix columns
colnames(answer_long) <- c("position", "List.ID", "Answer")
#match list id to participant data, which is only numbers
#list IDs can be characters or numbers
answer_long$List.ID <- gsub(pattern = "List",
replacement = "",
x = answer_long$List.ID)
head(answer_long)
DF_long$response <- tolower(DF_long$response)
answer_long$Answer <- tolower(answer_long$Answer)
answer_long$Answer <- tolower(answer_long$Answer)
answer_long$Answer <- gsub(" ", "", answer_long$Answer)
head(answer_long)
head(DF_long)
head(answer_long)
free_output <- prop_correct_multiple(data = DF_long,
responses = "response",
key = answer_long$Answer,
key.trial = answer_long$List.ID,
id = "Sub.ID",
id.trial = "List.Number",
cutoff = 1,
flag = TRUE)
str(free_output)
View(free_output$DF_Participant)
View(free_output$DF_Scored)
#Overall
free_output$DF_Scored
#Participant
free_output$DF_Participant
#Group
#free_output$DF_Group
?serial_position_multiple
??serial_position_multiple
