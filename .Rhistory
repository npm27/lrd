DF_serial
View(DF_serial)
head(DF_serial)
colnames(DF_serial)[ncol(DF_serial)] <- "Sum"
View(DF_serial)
group_sizes <- tapply(DF$Sub.ID, list(DF[ , group.by]), length)
group_sizes
DF_unique <- unique(DF[ , c("Sub.ID", group.by)])
View(DF_unique)
group_sizes <- tapply(DF_unique$Sub.ID, list(DF_unique[ , group.by]), length)
group_sizes
DF$Proportion.Correct <- NA
group_code <- paste(DF[ , group.by])
group_code
DF_serial$Proportion.Correct <- NA
group_code <- paste(DF_serial[ , group.by])
group_code
View(DF_serial)
group_sizes\
data(mtcars)
stuff = tapply(mtcars$mpg, list(mtcars$cyl, mtcars$vs), mean)
stuff
unlist(stuff)
as.data.frame(stuff)
names(stuff)
group_sizes <- ave(DF_unique$Sub.ID, list(DF_unique[ , group.by]), length)
group_sizes <- ave(DF_unique$Sub.ID, list(DF_unique[ , group.by]), FUN = length)
group_sizes
group_sizes <- aggregate(DF_unique$Sub.ID,
list(DF_unique[ , group.by]),
FUN = length)
group_sizes
group_sizes <- table(DF_unique[ , c("Sub.ID", group.by)])
group_sizes
group_sizes <- table(DF_unique[ , group.by])
group.by
group_sizes
group_sizes <- as.data.frame(table(DF_unique[ , group.by])_
group_code <- paste(DF_serial[ , group.by])
DF_serial$Proportion.Correct <- NA
for (group in group_code){
DF_serial$Proportion.Correct[group_code == group] <- DF_serial$Sum / group_sizes
}
} else {
}
#summarize participant scores by group
DF_group_person <- aggregate(DF$Scored,
by = DF[ , c(group.by, "Sub.ID")],
FUN = function(x){sum(x)/k})
colnames(DF_group_person) <- c(group.by,"Sub.ID", "Mean")
#why does aggregate do this
#if one variable by has to be a list
#if more than one, no list allowed
if (length(group.by) > 1){
DF_group <- aggregate(DF_group_person$Mean,
by = DF_group_person[ , group.by], mean)
DF_group$SD <- aggregate(DF_group_person$Mean,
by = DF_group_person[ , group.by], sd)$x
DF_group$N <- aggregate(DF_group_person$Mean,
by = DF_group_person[ , group.by], length)$x
} else {
DF_group <- aggregate(DF_group_person$Mean,
by = list(DF_group_person[ , group.by]), mean)
DF_group$SD <- aggregate(DF_group_person$Mean,
by = list(DF_group_person[ , group.by]), sd)$x
DF_group$N <- aggregate(DF_group_person$Mean,
by = list(DF_group_person[ , group.by]), length)$x
}
colnames(DF_group) <- c(group.by, "Mean", "SD", "N")
return(list(DF_Scored = DF,
DF_Participant = DF_participant,
DF_Group = DF_group))
} else {
return(list(DF_Scored = DF,
DF_Participant = DF_participant))
}
}
group_sizes <- as.data.frame(table(DF_unique[ , group.by]))
group_sizes
as.data.frame(table(mtcars$cyl, mtcars$vs))
group_sizes$group_code <- paste(group_sizes[ , -ncol(group_sizes)])
group_sizes
for (group in group_code){
DF_serial$Proportion.Correct[group_code == group] <- DF_serial$Sum / group_sizes$Freq[group_code == group]
}
warnings()
group
DF_serial$Proportion.Correct <- NA
DF_serial$Proportion.Correct[group_code == group]
group_sizes$Freq[group_sizes$group_code == group]
DF_serial$Sum[group_code == group]
for (group in group_code){
DF_serial$Proportion.Correct[group_code == group] <- DF_serial$Sum[group_code == group] / group_sizes$Freq[group_sizes$group_code == group]
}
View(DF_serial)
2/20
DF_serial <- aggregate(DF$Serial.Yes,
by = list(DF[ , "Tested.Position"]),
sum, na.rm = T)
colnames(DF_serial)[ncol(DF_serial)] <- "Sum"
DF_serial
DF_serial <- aggregate(DF$Serial.Yes,
by = DF[ , c(group.by, "Tested.Position")],
sum, na.rm = T)
colnames(DF_serial)[ncol(DF_serial)] <- "Sum"
View(DF_serial)
DF_serial <- aggregate(DF$Serial.Yes,
by = list(DF[ , "Tested.Position"]),
sum, na.rm = T)
head(DF_serial)
colnames(DF_serial) <- c("Tested.Position", "Sum")
group_sizes <- length(unique(DF$Sub.ID))
group_sizes
DF_serial$Proportion.Correct <- DF_serial$Sum / group_sizes
View(DF_serial)
names(DF_serial)
source("R/serial_position.R")
serial_output <- serial_position(data = scored_output$DF_Scored,
key = DF_answer$Answer_Key,
position = "position",
scored = "Scored",
answer = "Answer",
group.by = "Version")
head(serial_output)
serial_output
View(serial_output)
#first, figure all all the possible lags
max(serial_output$Tested.Position)
DF_test <- read.csv("data/free_data.csv")
DF_answer <- read.csv("data/answer_key_free2.csv")
colnames(DF_answer)[1] <- "Answer_Key" #Remove weird characters
source("R/prop_correct_free.R")
source("R/arrange_data.R")
DF_test <- subset(DF_test,
List_Type == "Cat_Recall_L1")
DF_long <- arrange_data(responses = DF_test$Response,
sep = " ",
id = DF_test$Username,
other = DF_test$Version,
other.names = "Version")
scored_output <- prop_correct_free( data = DF_long,
responses = "response",
key = DF_answer$Answer_Key,
id = "Sub.ID",
cutoff = 1,
flag = TRUE,
group.by = "Version")
key = DF_answer$Answer_Key
data = scored_output$DF_Scored
position = "position"
scored = "Scored"
answer = "Answer"
group.by = "Version"
#create answer key with order
if (sum(duplicated(key)) > 0){
stop("Your answer key contains duplicates. Please check your data.")
}
key <- data.frame("Answer" = key, "Tested.Position" = 1:length(key))
#merge that with the data
DF <- as.data.frame(data)
colnames(DF)[grepl(answer, colnames(DF))] <- "Answer"
colnames(DF)[grepl(position, colnames(DF))] <- "Answered.Position"
colnames(DF)[grepl(scored, colnames(DF))] <- "Scored"
DF <- merge(DF, key, by = "Answer")
#calculate the number of times within window
DF$Answered.Position <- as.numeric(DF$Answered.Position)
DF$Tested.Position <- as.numeric(DF$Tested.Position)
DF$Lag <- DF$Tested.Position - DF$Answered.Position
View(DF)
names(DF)
head(DF)
i = "A3SATHBTQSEJKF"
temp_part <- subset(DF,
Sub.ID == i)
View(temp_part)
temp_part <- temp_part[order(DF$Answered.Position)]
temp_part <- temp_part[order(DF$Answered.Position), ]
temp_part <- subset(DF,
Sub.ID == i)
temp_part <- temp_part[order(temp_part$Answered.Position), ]
View(temp_part)
?cumsum
diff(temp_part$Tested.Position)
possible_lags <- diff(temp_part$Tested.Position)
participant_lags <- diff(temp_part$Tested.Position)
possible_lags <- c()
number_spots <- max(DF$Tested.Position)
number_spots
number_spots <- 1:max(DF$Tested.Position)
j = 1
number_spots <- 1:max(DF$Tested.Position)
#take up to the current answered position
current <- temp_part$Answered.Position[1:j]
current
#take up to the current answered position
current <- temp_part$Tested.Position[1:j]
answers_left <- setdiff(current, number_spots)
answers_left
#take up to the current answered position
current <- temp_part$Tested.Position[1:j]
answers_left <- setdiff(current, number_spots)
answers_left
answers_left <- setdiff(number_spots, current)
answers_left
current_spot <- temp_part$Tested.Position[j]
current_spot - answers_left
answers_left - current_spot
j = 3
#take up to the current answered position
current_used <- temp_part$Tested.Position[1:j]
current_used
answers_left <- setdiff(number_spots, current)
answers_left
answers_left <- setdiff(number_spots, current_used)
answers_left
current_spot <- temp_part$Tested.Position[j]
current_spot
answers_left - current_spot
participant_lags <- diff(temp_part$Tested.Position)
participant_lags
#participant lags
for (j in 1:nrow(temp_part)){
#take up to the current answered position
current_used <- temp_part$Tested.Position[1:j]
answers_left <- setdiff(number_spots, current_used)
current_spot <- temp_part$Tested.Position[j]
possible_lags <- c(possible_lags, answers_left - current_spot)
}
possible_lags
table(participant_lags, possible_lags)
table(participant_lags)
table(possible_lags)
table_possible_lags <- table(possible_lags)
table_possible_lags <- as.data.frame(table(possible_lags))
table_possible_lags
table_part_lags
table_part_lag
table_part_lags <- as.data.frame(table(participant_lags))
table_part_lags
colnames(table_possible_lags) <- c("participant_lags", "Possible.Freq")
table_part_lags <- merge(table_part_lags,
table_possible_lags,
by = "participant_lags")
table_part_lags
table_part_lags$Sub.ID <- i
table_part_lags
head(temp_part)
names(DF)
#add back in other columns that are one to one
other.columns <- setdiff(colnames(DF),
c("Responses", "Sub.ID", "Answer", "Scored",
colnames(table_part_lags)))
other.columns
#add back in other columns that are one to one
other.columns <- setdiff(colnames(DF),
c("Responses", "Sub.ID", "Answer",
"Scored", "Answered.Position",
"Tested.Position", "Lag",
colnames(table_part_lags)))
other.columns
for (col in other.columns){
DF_temp <- unique(DF[ , c("Sub.ID", col)])
if (sum(duplicated(DF_temp$Sub.ID)) == 0){
table_part_lags <- merge(table_part_lags, DF_temp, by = "Sub.ID")
}
}
table_part_lags
is.null(DF_final)
exists(DF_final)
DF_final <- table_part_lags
DF_final
DF_final <- rbind(DF_final, table_part_lags)
DF_final
DF_final <- NULL
#for each participant calculate the possible lags
for (i in DF$Sub.ID){
temp_part <- subset(DF,
Sub.ID == i)
temp_part <- temp_part[order(temp_part$Answered.Position), ]
participant_lags <- diff(temp_part$Tested.Position)
possible_lags <- c()
#participant lags
for (j in 1:nrow(temp_part)){
#take up to the current answered position
current_used <- temp_part$Tested.Position[1:j]
answers_left <- setdiff(number_spots, current_used)
current_spot <- temp_part$Tested.Position[j]
possible_lags <- c(possible_lags, answers_left - current_spot)
} #answers loop
table_part_lags <- as.data.frame(table(participant_lags))
table_possible_lags <- as.data.frame(table(possible_lags))
colnames(table_possible_lags) <- c("participant_lags", "Possible.Freq")
table_part_lags <- merge(table_part_lags,
table_possible_lags,
by = "participant_lags")
table_part_lags$Sub.ID <- i
#add back in other columns that are one to one
other.columns <- setdiff(colnames(DF),
c("Responses", "Sub.ID", "Answer",
"Scored", "Answered.Position",
"Tested.Position", "Lag",
colnames(table_part_lags)))
for (col in other.columns){
DF_temp <- unique(DF[ , c("Sub.ID", col)])
if (sum(duplicated(DF_temp$Sub.ID)) == 0){
table_part_lags <- merge(table_part_lags, DF_temp, by = "Sub.ID")
}
} #for other columns
if (is.null(DF_final)){
DF_final <- table_part_lags
} else {
DF_final <- rbind(DF_final, table_part_lags)
}
} #participant loop
table_part_lags
temp_part
View(DF)
participant_lags
DF_final <- NULL
#for each participant calculate the possible lags
for (i in DF$Sub.ID){
temp_part <- subset(DF,
Sub.ID == i)
temp_part <- temp_part[order(temp_part$Answered.Position), ]
participant_lags <- diff(temp_part$Tested.Position)
possible_lags <- c()
if (nrow(temp_part) > 1){
#participant lags
for (j in 1:nrow(temp_part)){
#take up to the current answered position
current_used <- temp_part$Tested.Position[1:j]
answers_left <- setdiff(number_spots, current_used)
current_spot <- temp_part$Tested.Position[j]
possible_lags <- c(possible_lags, answers_left - current_spot)
} #answers loop
table_part_lags <- as.data.frame(table(participant_lags))
table_possible_lags <- as.data.frame(table(possible_lags))
colnames(table_possible_lags) <- c("participant_lags", "Possible.Freq")
table_part_lags <- merge(table_part_lags,
table_possible_lags,
by = "participant_lags")
table_part_lags$Sub.ID <- i
#add back in other columns that are one to one
other.columns <- setdiff(colnames(DF),
c("Responses", "Sub.ID", "Answer",
"Scored", "Answered.Position",
"Tested.Position", "Lag",
colnames(table_part_lags)))
for (col in other.columns){
DF_temp <- unique(DF[ , c("Sub.ID", col)])
if (sum(duplicated(DF_temp$Sub.ID)) == 0){
table_part_lags <- merge(table_part_lags, DF_temp, by = "Sub.ID")
}
} #for other columns
if (is.null(DF_final)){
DF_final <- table_part_lags
} else {
DF_final <- rbind(DF_final, table_part_lags)
}
} #must have more than one row
} #participant loop
View(DF_final)
DF_final$CRP <- DF_final$Freq / DF_final$Possible.Freq
View(DF_final)
View(DF
)
DF_test <- read.csv("data/free_data.csv")
DF_answer <- read.csv("data/answer_key_free2.csv")
colnames(DF_answer)[1] <- "Answer_Key" #Remove weird characters
source("R/prop_correct_free.R")
source("R/arrange_data.R")
DF_test <- subset(DF_test,
List_Type == "Cat_Recall_L1")
DF_long <- arrange_data(responses = DF_test$Response,
sep = " ",
id = DF_test$Username,
other = DF_test$Version,
other.names = "Version")
scored_output <- prop_correct_free( data = DF_long,
responses = "response",
key = DF_answer$Answer_Key,
id = "Sub.ID",
cutoff = 1,
flag = TRUE,
group.by = "Version")
key = DF_answer$Answer_Key
data = scored_output$DF_Scored
position = "position"
scored = "Scored"
answer = "Answer"
group.by = "Version"
source("R/serial_position.R")
serial_output <- serial_position(data = scored_output$DF_Scored,
key = DF_answer$Answer_Key,
position = "position",
scored = "Scored",
answer = "Answer",
group.by = "Version")
head(serial_output)
View(serial_output)
View(data)
DF_test <- read.csv("data/free_data.csv")
DF_answer <- read.csv("data/answer_key_free2.csv")
colnames(DF_answer)[1] <- "Answer_Key" #Remove weird characters
source("R/prop_correct_free.R")
source("R/arrange_data.R")
DF_test <- subset(DF_test,
List_Type == "Cat_Recall_L1")
DF_long <- arrange_data(responses = DF_test$Response,
sep = " ",
id = DF_test$Username,
other = DF_test$Version,
other.names = "Version")
scored_output <- prop_correct_free( data = DF_long,
responses = "response",
key = DF_answer$Answer_Key,
id = "Sub.ID",
cutoff = 1,
flag = TRUE,
group.by = "Version")
source("R/crp.R")
names(scored_output$DF_Scored)
source('~/GitHub/2.5 packages/lrd/tests/test crp.R', echo=TRUE)
crp_output <- crp(data = scored_output$DF_Scored,
position = "position",
answer = "Answer",
id = "Sub.ID",
key = DF_answer$Answer_Key,
scored = "Scored")
head(crp_output)
View(serial_output)
#create answer key with order
if (sum(duplicated(key)) > 0){
stop("Your answer key contains duplicates. Please check your data.")
}
key <- data.frame("Answer" = key, "Tested.Position" = 1:length(key))
#merge that with the data
DF <- as.data.frame(data)
colnames(DF)[grepl(answer, colnames(DF))] <- "Answer"
colnames(DF)[grepl(position, colnames(DF))] <- "Answered.Position"
colnames(DF)[grepl(scored, colnames(DF))] <- "Scored"
colnames(DF)[grepl(id, colnames(DF))] <- "Sub.ID"
DF <- merge(DF, key, by = "Answer")
#calculate the number of times within window
DF$Answered.Position <- as.numeric(DF$Answered.Position)
DF$Tested.Position <- as.numeric(DF$Tested.Position)
View(DF)
DF_first <- subset(DF, Answered.Position == 1)
View(DF_first)
pfr_table <- table(DF_first$Test)
pfr_table <- table(DF_first$Tested.Position)
pfr_table
group.by
if(!is.null(group.by)){
pfr_table <- table(DF_first[ , c("Tested.Position", group.by)])
}
pfr_table
pfr_table <- as.data.frame(table(DF_first[ , c("Tested.Position", group.by)]))
pfr_table
DF_unique <- unique(DF[ , c("Sub.ID", group.by)])
group_sizes <- as.data.frame(table(DF_unique[ , group.by]))
group_sizes$group_code <- paste(group_sizes[ , -ncol(group_sizes)])
group_code <- paste(pfr_table[ , group.by])
pfr_table$pfr <- NA
for (group in group_code){
pfr_table$pfr[group_code == group] <- pfr_table$Freq[group_code == group] / group_sizes$Freq[group_sizes$group_code == group]
}
View(pfr_table)
names(pfr_table)
DF_test <- read.csv("data/free_data.csv")
DF_answer <- read.csv("data/answer_key_free2.csv")
colnames(DF_answer)[1] <- "Answer_Key" #Remove weird characters
source("R/prop_correct_free.R")
source("R/arrange_data.R")
DF_test <- subset(DF_test,
List_Type == "Cat_Recall_L1")
DF_long <- arrange_data(responses = DF_test$Response,
sep = " ",
id = DF_test$Username,
other = DF_test$Version,
other.names = "Version")
scored_output <- prop_correct_free( data = DF_long,
responses = "response",
key = DF_answer$Answer_Key,
id = "Sub.ID",
cutoff = 1,
flag = TRUE,
group.by = "Version")
source("R/pfr.R")
pfr_output <- pfr(data = scored_output$DF_Scored,
position = "position",
answer = "Answer",
id = "Sub.ID",
key = DF_answer$Answer_Key,
scored = "Scored",
group.by = "Version")
head(pfr_output)
colnames(DF
)
c("Responses", "Sub.ID", "Answer",
"Scored", "Answered.Position",
"Tested.Position",
colnames(pfr_table))
#add back in other columns that are one to one
other.columns <- setdiff(colnames(DF),
c("Responses", "Sub.ID", "Answer",
"Scored", "Answered.Position",
"Tested.Position",
colnames(pfr_table)))
other.columns
crp_output
View(crp_output)
